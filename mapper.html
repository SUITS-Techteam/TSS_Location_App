<!DOCTYPE html>
<html>
<head>
    <title>Lunar Position Visualizer (Dual EVA with Paths)</title>
    <style>
        canvas {
            border: 1px solid #ccc;
            background-color: #000;
        }
        body {
            background-color: black;
            text-align: center;
            color: white;
        }
        button {
            margin: 10px;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <h1></h1>
    <canvas id="mapCanvas" width="2000" height="1100"></canvas>
    <div>
        <button onclick="toggleSimulation()">Toggle Simulation</button>
        <button onclick="togglePaths()">Toggle Paths</button>
    </div>

    <script>
        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        const serverUrl = "http://192.168.51.110:14141";  // Update with correct IP if needed
        const mapImage = new Image();
        mapImage.src = "SUIT_MAP.png";

        // Map boundaries
        const left = -5800;
        const right = -5600;
        const bottom = -10100;
        const topBound = -10000;

        let simulationMode = true;
        let showPaths = true;

        // Simulation Variables for EVA1 and EVA2
        let simAngle1 = 0;
        let simAngle2 = Math.PI; // 180 degrees out of phase

        const simRadius = 50;
        const simCenterX = -5700;
        const simCenterY = -10050;

        // Path History Buffers
        const pathHistory = {
            eva1: [],
            eva2: []
        };
        const maxPathLength = 100;  // Limit history to 100 points

        mapImage.onload = () => {
            drawMap();
        };

        function toggleSimulation() {
            simulationMode = !simulationMode;
            alert(`Simulation Mode: ${simulationMode ? "ON" : "OFF"}`);
            clearPaths();
        }

        function togglePaths() {
            showPaths = !showPaths;
        }

        function clearPaths() {
            pathHistory.eva1 = [];
            pathHistory.eva2 = [];
        }

        function drawMap() {
            ctx.drawImage(mapImage, 0, 0, canvas.width, canvas.height);
        }

        function mapToCanvas(x, y) {
            const scaledX = ((x - left) / (right - left)) * canvas.width;
            const scaledY = canvas.height - ((y - bottom) / (topBound - bottom)) * canvas.height;
            return [scaledX, scaledY];
        }

        function drawPath(path, color) {
            if (path.length < 2) return;

            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;

            const [startX, startY] = mapToCanvas(path[0][0], path[0][1]);
            ctx.moveTo(startX, startY);

            for (let i = 1; i < path.length; i++) {
                const [x, y] = mapToCanvas(path[i][0], path[i][1]);
                ctx.lineTo(x, y);
            }

            ctx.stroke();
        }

        function drawPosition(x, y, color, eva) {
            // Update Path History
            pathHistory[eva].push([x, y]);
            if (pathHistory[eva].length > maxPathLength) {
                pathHistory[eva].shift();
            }

            if (showPaths) {
                drawPath(pathHistory[eva], color);
            }

            const [canvasX, canvasY] = mapToCanvas(x, y);
            ctx.beginPath();
            ctx.arc(canvasX, canvasY, 8, 0, 2 * Math.PI);
            ctx.fillStyle = color;
            ctx.fill();
        }

        async function fetchPosition() {
            drawMap();

            if (simulationMode) {
                // EVA1 Simulation
                simAngle1 += 0.05;
                const x1 = simCenterX + simRadius * Math.cos(simAngle1);
                const y1 = simCenterY + simRadius * Math.sin(simAngle1);
                drawPosition(x1, y1, "red", "eva1");

                // EVA2 Simulation
                simAngle2 += 0.05;
                const x2 = simCenterX + simRadius * Math.cos(simAngle2);
                const y2 = simCenterY + simRadius * Math.sin(simAngle2);
                drawPosition(x2, y2, "blue", "eva2");

            } else {
                try {
                    const response = await fetch(serverUrl);
                    const data = await response.text();

                    const params = new URLSearchParams(data);

                    const posx1 = parseFloat(params.get("imu_eva1_posx")) || 0;
                    const posy1 = parseFloat(params.get("imu_eva1_posy")) || 0;

                    const posx2 = parseFloat(params.get("imu_eva2_posx")) || 0;
                    const posy2 = parseFloat(params.get("imu_eva2_posy")) || 0;

                    drawPosition(posx1, posy1, "red", "eva1");
                    drawPosition(posx2, posy2, "blue", "eva2");

                } catch (e) {
                    console.error("Error fetching position:", e);
                }
            }
        }

        setInterval(fetchPosition, 1000);
    </script>
</body>
</html>
